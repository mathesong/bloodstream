#' Extract filterable attributes from a BIDS list
#'
#' This function extracts the attributes which could be used for filtering. By
#' this, it extracts all parts of the list which are either character or numeric
#' which also have a length of 1. This allows us to filter our data for a
#' specific tracer, or injection type.
#'
#' @param list The list of PET data or blood data
#'
#' @return A data.frame containing the filterable attributes
#' @export
get_filterable_attributes <- function(list) {

  lengths <- purrr::map_dbl(list, length) == 1
  types <- purrr::map_dbl(list, ~is.character(.x)  || is.numeric(.x))
  keep <- lengths * types

  outlist <- list[which(keep==1)]

  outlist <- outlist[which(names(outlist) %in% c("TracerName",
                        "ModeOfAdministration",
                        "InstitutionName",
                        "PharmaceuticalName"))]

  tibble::as_tibble(outlist)


}

#' Generate methods boilerplate text for manuscript reporting
#'
#' @param config The bloodstream configuration list
#' @param package_version The version of bloodstream used
#' @return A character string containing the formatted methods text
#' @export
generate_methods_boilerplate <- function(config, package_version = NULL) {

  # Get package version if not provided
  if (is.null(package_version)) {
    package_version <- utils::packageVersion("bloodstream")
  }

  # Helper function to describe models
  describe_model <- function(method, component_config = NULL) {
    switch(method,
      "Interpolation" = "linear interpolation",
      "Fit Individually: Choose the best-fitting model" = "best-fitting parametric model selection among Hill, exponential, power, sigmoid, inverse gamma, and gamma functions",
      "Fit Individually: Hill" = "Hill model",
      "Fit Individually: Exponential" = "exponential decay model",
      "Fit Individually: Power" = "power function model",
      "Fit Individually: Sigmoid" = "sigmoid model",
      "Fit Individually: Inverse Gamma" = "inverse gamma model",
      "Fit Individually: Gamma" = "gamma model",
      "Fit Individually: GAM" = {
        k_val <- if (!is.null(component_config$gam_k)) paste0("k=", component_config$gam_k) else "k=6"
        paste0("generalized additive model (GAM) with ", k_val, " basis functions")
      },
      "Fit Hierarchically: HGAM" = "hierarchical generalized additive model (HGAM)",
      "Fit Individually: Constant" = "constant model",
      "Fit Individually: Linear" = "linear model",
      "Fit Individually: Linear Rise, Triexponential Decay" = "triexponential decay with linear rise",
      "Fit Individually: Feng" = "Feng model",
      "Fit Individually: FengConv" = "Feng model with convolution",
      "Fit Individually: Splines" = "spline-based modeling",
      method  # fallback to original method name
    )
  }

  # Generate model descriptions
  pf_desc <- describe_model(config$Model$ParentFraction$Method, config$Model$ParentFraction)
  if (!is.null(config$Model$ParentFraction$set_ppf0) && config$Model$ParentFraction$set_ppf0) {
    pf_desc <- paste0(pf_desc, " with the constraint that the parent fraction is equal to 1 at t=0")
  }

  bpr_desc <- describe_model(config$Model$BPR$Method, config$Model$BPR)
  aif_desc <- describe_model(config$Model$AIF$Method, config$Model$AIF)
  wb_desc <- describe_model(config$Model$WholeBlood$Method, config$Model$WholeBlood)

  # Add dispersion correction note for whole blood if applicable
  if (!is.null(config$Model$WholeBlood$dispcor) && config$Model$WholeBlood$dispcor) {
    wb_desc <- paste0(wb_desc, " with dispersion correction")
  }

  # Generate the boilerplate text
  methods_text <- paste0(
    "## Methods\n\n",
    "You can use the following text to describe the results of this analysis.\n\n",
    "Blood data preprocessing was performed using *bloodstream* ", package_version, ", ",
    "which is based on *kinfitr* (Matheson, 2019; Tjerkaski et al., 2020).\n\n",
    "**Blood data processing:** Blood samples were processed as follows. ",
    "Parent fraction data were modeled using ", pf_desc, ". ",
    "Blood-to-plasma ratio was estimated using ", bpr_desc, ". ",
    "Arterial input function was processed using ", aif_desc, ". ",
    "Whole blood data were processed using ", wb_desc, ". ",
    ".\n\n",
    "For more details of the pipeline, see the bloodstream documentation at [https://github.com/mathesong/bloodstream](https://github.com/mathesong/bloodstream).\n\n",
    "### Copyright Waiver\n\n",
    "The above boilerplate text was automatically generated by bloodstream so that users can copy and paste this text into their manuscripts. It is released under the [CC0](https://creativecommons.org/publicdomain/zero/1.0/) license."
  )

  return(methods_text)
}

#' @export
extract_extra_attributes <- function(bidsdata) {

  petinfoextract <- function(petinfo, detail) petinfo[[detail]]

  safely_extract <- purrr::possibly(.f = petinfoextract, otherwise = "")

  bidsdata$TracerName = purrr::map_chr(bidsdata$petinfo,
                                       safely_extract,
                                       detail="TracerName")
  bidsdata$ModeOfAdministration = purrr::map_chr(bidsdata$petinfo,
                                                 safely_extract,
                                                 detail="ModeOfAdministration")
  bidsdata$InstitutionName = purrr::map_chr(bidsdata$petinfo,
                                            safely_extract,
                                            detail="InstitutionName")
  bidsdata$PharmaceuticalName = purrr::map_chr(bidsdata$petinfo,
                                               safely_extract,
                                               detail="PharmaceuticalName")

}

#' @export
get_petname <- function(filedata) {

  petname <- filedata %>%
    dplyr::filter(measurement == "blood") %>%
    dplyr::slice(1)

  petname <- basename(petname$path)
  stringr::str_remove(petname,
                                 "_recording.*")

}

#' @export
attributes_to_title <- function(bidsdata, all_attributes = FALSE) {


  if( !all_attributes ) {
    if(nrow(bidsdata) > 1) {
      # More than one PET measurement
      bidsdata <- bidsdata[,which(!apply(bidsdata, 2,
                                         FUN = function(x) length(unique(x))==1))]
    } else {
      # Situation if only one PET
      bidsdata <- dplyr::select(bidsdata, sub, ses, task, filedata)
    }
  }

  cnames <- colnames(bidsdata)

  filedata_colno <- which(cnames=="filedata")

  cname_attributes <- cnames[1:(filedata_colno-1)]
  attributes <- bidsdata[1:(filedata_colno-1)]

  # i for rows --> attributes
  # j for columns --> measurements

  title <- rep("", times=nrow(attributes))

  for(j in 1:nrow(attributes)) {
    for(i in 1:length(cname_attributes)) {
      title[j] <- paste0(title[j], cname_attributes[i], "-", attributes[j,i], "_")
    }
  }

  stringr::str_remove(title, "_$")

}

#' @export
fitted_values_nonzerotime <- function(gamfit, data, zeroval = 1) {

  data_zero <- data %>%
    dplyr::filter(time == 0)

  data_nonzero <- data %>%
    dplyr::filter(time > 0)

  nonzero_preds <- gratia::fitted_values(gamfit, data_nonzero)

  zero_preds <- nonzero_preds %>%
    dplyr::filter(time == min(time)) %>%
    dplyr::mutate(time = 0) %>%
    dplyr::mutate(.row = 0)

  preds <- dplyr::bind_rows(zero_preds, nonzero_preds) %>%
    dplyr::arrange(time)

  return(preds)

}

