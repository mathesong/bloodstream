---
title: "Blood Processing Analysis"
params:
  configpath: "../extdata/config_default.json"
  studypath: "../../../ds004230/"
output:
  html_document:
    toc: true
    toc-depth: 2
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r libraries, warning=FALSE}
#| output: false

library(tidyverse)
library(jsonlite)
library(cowplot)
library(stringr)
library(knitr)
library(mgcv)
library(gratia)
library(glue)

library(kinfitr)
library(bloodstream)

configpath <- params$configpath
configname <- basename(configpath)

config_suffix <- str_match(configname, "^config_?-?(.*)\\.json")[,2]

config <- jsonlite::fromJSON(configpath)
config_subset <- parse_config_subsets(config)

theme_set(theme_light())
```



## Modelling

Here are the contents of the config file with regard to which models will be fit to the data and how.

```{r}
str(config$Model)
```


## Load the data
<!-- No subsetting -->

```{r}
#| echo: false

subsetting <- (ncol(config_subset) > 0)
no_subsetting <- !subsetting
```

```{r load-data, eval=no_subsetting,echo=no_subsetting}
bidsdata <- bids_parse_study(params$studypath)

extra_pet_details <- map(bidsdata$petinfo,
                           get_filterable_attributes) %>%
    bind_rows()

bidsdata <- bind_cols(extra_pet_details, bidsdata) %>%
    all_identifiers_to_character()

  
bidsdata$pet <- attributes_to_title(bidsdata)
bidsdata$fulltitle <- attributes_to_title(bidsdata, all_attributes = T)
```

<!-- Subsetting -->

```{r subsetting, eval=subsetting,echo=subsetting}
# Subsetting

### Extract measurement information
measurements <- bids_parse_files(params$studypath) %>%
  mutate(petinfo = map(filedata,
                            kinfitr:::bids_parse_petinfo))

extra_pet_details <- map(measurements$petinfo,
                         get_filterable_attributes) %>%
  bind_rows()

measurements <- bind_cols(extra_pet_details, measurements) %>%
  all_identifiers_to_character()


### Filter
measurements <- measurements %>%
  inner_join(config_subset, 
             by = colnames(config_subset))


### Continue to process
bidsdata <- measurements
bidsdata$blooddata <- purrr::map(bidsdata$filedata,
    bids_create_blooddata)
bidsdata$tactimes <- purrr::map(bidsdata$filedata,
    kinfitr:::bids_parse_pettimes)
bidsdata <- dplyr::filter(bidsdata, !is.na(tactimes))

bidsdata$pet <- attributes_to_title(bidsdata)
bidsdata$fulltitle <- attributes_to_title(bidsdata, all_attributes = T)
```






<!-- Data Subsetting -->

```{r, eval=subsetting,echo=subsetting  }
#| results: asis
#| echo: false

str_glue("## Data Subset

           Based on the config file, only a subset of the data will be processed in this analysis. The subsets defined are as follows:")
```

```{r, eval=subsetting,echo=subsetting }
kable(config_subset)
```

```{r, eval=subsetting,echo=subsetting }
#| results: asis
#| echo: false

str_glue("The resulting list of blood measurements in the following analysis are as follows:")
```

```{r}
#| echo: false
bidsdata_attributes <- bidsdata %>% 
  select(1:(which(colnames(bidsdata)=="filedata")-1), pet)
```

```{r subsetted-data,echo=FALSE, eval=subsetting}
kable(bidsdata_attributes)
```

```{r}
#| echo: false

do_dispcor <- config$Model$WholeBlood$dispcor
```

```{r,echo=do_dispcor, eval=do_dispcor}
#| results: asis

str_glue("## Dispersion Correction
         
         Now we perform dispersion correction to account for dispersion through the tubing for the blood samples from the autosampler.")
```

```{r,echo=do_dispcor, eval=do_dispcor}
# Check if specified
for(i in 1:nrow(bidsdata)) {
  
  if(  is.null(bidsdata$blooddata[[i]]$Data$Blood$Continuous$DispersionCorrected)  ) {
    bidsdata$blooddata[[i]]$Data$Blood$Continuous$DispersionCorrected <- FALSE
  }
  
  if( is.null(bidsdata$blooddata[[i]]$Data$Blood$Continuous$DispersionConstant) ) {
    warning("No dispersion constant is available for performing dispersion correction. No dispersion correction applied.\n\n")
  } else{
    
    bidsdata$blooddata[[i]] <- bd_blood_dispcor(bidsdata$blooddata[[i]])
  }
}
```


## Quality Control

#### Parent Fraction

```{r}
#| results: asis
pf_warnings <- map2_chr(bidsdata$blooddata, bidsdata$pet, qc_parentFraction)

pf_warnings <- pf_warnings[!is.na(pf_warnings)]

if(length(pf_warnings) > 0) {
  glue_collapse(pf_warnings)
} else {
  glue_collapse("No detected issues.")
}
```

#### Blood-to-Plasma Ratio

```{r}
#| results: asis
bpr_warnings <- map2_chr(bidsdata$blooddata, bidsdata$pet, qc_bpr)

bpr_warnings <- bpr_warnings[!is.na(bpr_warnings)]

if(length(bpr_warnings) > 0) {
  glue_collapse(bpr_warnings)
} else {
  glue_collapse("No detected issues.")
}
```

#### Whole Blood

```{r}
#| results: asis
wb_warnings <- map2_chr(bidsdata$blooddata, bidsdata$pet, qc_wb)

wb_warnings <- wb_warnings[!is.na(wb_warnings)]

if(length(wb_warnings) > 0) {
  glue_collapse(wb_warnings)
} else {
  glue_collapse("No detected issues.")
}
```



### Plotting

Below is the raw blood data prior to any modelling. Inspect these plots to to check for strange values. The left plot is with the original times, while the right plot presents a log-scaled x axis, allowing closer inspection of the early parts of the curve.

```{r initial-plotting, fig.height=5, fig.width=11}
#| warning: false
#| message: false
#| fig-height: 5
#| fig-width: 11

map2(bidsdata$blooddata, bidsdata$pet,
     ~plot_blooddata_extra(.x, .y)) 
```

## Modelling

### Parent Fraction

The selected modelling approach for modelling the parent fraction (PF) data is `r config$Model$ParentFraction$Method`.

```{r}
#| echo: false


fit_pf <- config$Model$ParentFraction$Method != "Interpolation"

choose_best_model <- (config$Model$ParentFraction$Method=="Fit Individually: Choose the best-fitting model")
```

<!-- Choose the best model -->

```{r pf-modelcompare, eval=choose_best_model,echo=choose_best_model}
#| fig-height: 4
#| fig-width: 7

pf_modelcompare <- compare_aic_metabmodels_group(bidsdata,
                            fit_ppf0 = !config$Model$ParentFraction$set_ppf0,
                            starttime = config$Model$ParentFraction$starttime,
                            endtime = config$Model$ParentFraction$endtime,
                            gam_k = as.numeric(config$Model$ParentFraction$gam_k))

pf_modelcompare$plot

kable(pf_modelcompare$scores)
```

```{r pf-modelcompare-description, eval=choose_best_model,echo=choose_best_model}
#| results: asis
#| echo: false

str_glue("Based on the overall sum of the AIC scores, the winning model is `",
       pf_modelcompare$scores$Model[1], "`. The parent fraction curves ",
       "will therefore be fit using this method.")

```

```{r pf-model-update, eval=choose_best_model,echo=choose_best_model}
#| echo: false

config$Model$ParentFraction$Method <- paste0("Fit Individually: ",
                                             pf_modelcompare$scores$Model[1])
```

```{r pf-setup}
#| echo: false

do_hill <- (config$Model$ParentFraction$Method=="Fit Individually: Hill")
do_exp <-(config$Model$ParentFraction$Method=="Fit Individually: Exponential")
do_power <-(config$Model$ParentFraction$Method=="Fit Individually: Power")
do_sigmoid <-(config$Model$ParentFraction$Method=="Fit Individually: Sigmoid")
do_invgamma <-(config$Model$ParentFraction$Method=="Fit Individually: Inverse Gamma")
do_gamma <-(config$Model$ParentFraction$Method=="Fit Individually: Gamma")
do_gam <-(config$Model$ParentFraction$Method=="Fit Individually: GAM")
do_hgam <- (config$Model$ParentFraction$Method=="Fit Hierarchically: HGAM")

parametric_pf <- any(do_hill, do_exp, do_power, do_sigmoid, 
                     do_invgamma, do_gamma)
# nonparam_pf <- !parametric_pf
```


```{r pf-hill,echo=do_hill, eval=do_hill}
#| fig-height: 4
#| fig-width: 5

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

# Fit Model
pf_data <- pf_data %>%
  mutate(pf_fit = map(pf, ~metab_hill(.x$time, .x$parentFraction,
                            fit_ppf0 = !config$Model$ParentFraction$set_ppf0)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

pf_data <- pf_data %>%
  mutate(preds = map(pf_fit, ~tibble(
    time = predtimes) %>%
      mutate(parentFraction = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```

```{r pf-exp,echo=do_exp, eval=do_exp}
#| fig-height: 4
#| fig-width: 5

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

# Fit Model
pf_data <- pf_data %>%
  mutate(pf_fit = map(pf, ~metab_exponential(.x$time, .x$parentFraction,
                            fit_ppf0 = !config$Model$ParentFraction$set_ppf0)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

pf_data <- pf_data %>%
  mutate(preds = map(pf_fit, ~tibble(
    time = predtimes) %>%
      mutate(parentFraction = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```

```{r pf-power,echo=do_power, eval=do_power}
#| fig-height: 4
#| fig-width: 5

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

# Fit Model
pf_data <- pf_data %>%
  mutate(pf_fit = map(pf, ~metab_power(.x$time, .x$parentFraction,
                            fit_ppf0 = !config$Model$ParentFraction$set_ppf0)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

pf_data <- pf_data %>%
  mutate(preds = map(pf_fit, ~tibble(
    time = predtimes) %>%
      mutate(parentFraction = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```

```{r pf-sigmoid,echo=do_sigmoid, eval=do_sigmoid}
#| fig-height: 4
#| fig-width: 5

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

# Fit Model
pf_data <- pf_data %>%
  mutate(pf_fit = map(pf, ~metab_sigmoid(.x$time, .x$parentFraction,
                            fit_ppf0 = !config$Model$ParentFraction$set_ppf0)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

pf_data <- pf_data %>%
  mutate(preds = map(pf_fit, ~tibble(
    time = predtimes) %>%
      mutate(parentFraction = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```

```{r pf-invgamma,echo=do_invgamma, eval=do_invgamma}
#| fig-height: 4
#| fig-width: 5

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

# Fit Model
pf_data <- pf_data %>%
  mutate(pf_fit = map(pf, ~metab_invgamma(.x$time, .x$parentFraction,
                            fit_ppf0 = !config$Model$ParentFraction$set_ppf0)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

pf_data <- pf_data %>%
  mutate(preds = map(pf_fit, ~tibble(
    time = predtimes) %>%
      mutate(parentFraction = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```

```{r pf-gamma,echo=do_gamma, eval=do_gamma}
#| fig-height: 4
#| fig-width: 5

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

# Fit Model
pf_data <- pf_data %>%
  mutate(pf_fit = map(pf, ~metab_gamma(.x$time, .x$parentFraction,
                            fit_ppf0 = !config$Model$ParentFraction$set_ppf0)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

pf_data <- pf_data %>%
  mutate(preds = map(pf_fit, ~tibble(
    time = predtimes) %>%
      mutate(parentFraction = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```


```{r, eval=parametric_pf}
#| results: asis
#| echo: false

str_glue("The fitted parameters are shown below.")
```

```{r pf-parameters,echo=parametric_pf, eval=parametric_pf}
pf_pars <- pf_data %>% 
  mutate(pf_pars = map(pf_fit, ~as_tibble(as.list(coef(.x))))) %>% 
  select(pet, pf_pars)

pf_pars %>% 
  unnest() %>% 
  kable(digits=3)
```



```{r pf-gam,echo=do_gam, eval=do_gam}
#| fig-height: 4
#| fig-width: 5

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

# Fit Model
config_pc <- ifelse(config$Model$ParentFraction$set_ppf0, 1, NULL)
pf_gam_k <- as.numeric(config$Model$ParentFraction$gam_k)

pf_data <- pf_data %>%
  mutate(pf = map(pf, ~.x %>% 
                    filter(time > 0) %>% 
  filter(parentFraction < 1) %>% 
  filter(parentFraction > 0))) %>% 
  mutate(pf_fit = map(pf, ~mgcv::gam(parentFraction ~ s(log(time), 
                                       k=pf_gam_k, 
                                       pc=config_pc), 
                                     data=.x, method = "REML",
                                     family=betar(link="logit"))))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

pf_data <- pf_data %>%
  mutate(preds = map2(pf_fit, pf,
                      ~fitted_values_nonzerotime(.x, data=tibble(time=predtimes)))) %>% 
  mutate(preds = map(preds, ~rename(.x, parentFraction = .fitted)))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```

```{r pf-hgam-fit,echo=do_hgam, eval=do_hgam}
#| fig-height: 4
#| fig-width: 8

# Extract Data
pf_data <- bidsdata %>%
  mutate(pf = map(blooddata, ~bd_extract(.x, output="parentFraction"))) %>%
  mutate(pf = map(pf, ~.x %>%
           filter(time >= as.numeric(config$Model$ParentFraction$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$ParentFraction$endtime)*60))) %>%
  select(pet, pf)

pf_data_long <- pf_data %>% 
  inner_join(bidsdata_attributes) %>% 
  unnest(pf) %>% 
  mutate(across(where(is.character), as.factor)) %>% 
  filter(time > 0) %>% 
  filter(parentFraction < 1) %>% 
  filter(parentFraction > 0)

# Fit Model
config_pc <- ifelse(config$Model$ParentFraction$set_ppf0, 1, NULL)
hgam_formula <- as.formula(
  paste0(
    "parentFraction ~ ",
    config$Model$ParentFraction$hgam_formula )
  )

pf_hgam_fit = mgcv::gam(formula = hgam_formula, 
                        data=pf_data_long, method = "REML",
                        family=betar(link="logit"))

# Diagnostics
k.check(pf_hgam_fit)
appraise(pf_hgam_fit)
draw(pf_hgam_fit, scales = "fixed")
```

```{r pf-hgam-plot,echo=do_hgam, eval=do_hgam}
#| fig-height: 4
#| fig-width: 5

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(pf_data$pf, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

hgam_preds <- tidyr::expand_grid(bidsdata_attributes,
                                 time = predtimes)

hgam_preds <- fitted_values_nonzerotime(pf_hgam_fit, data=hgam_preds) %>% 
  rename(parentFraction = .fitted) 

pf_data <- inner_join(pf_data,
                      hgam_preds %>% 
                      group_by(pet) %>% 
                      nest(preds = -pet))

# Plot
pmap(list(pf_data$pf, pf_data$preds, pf_data$pet), plot_pf_preds)
```




```{r, eval=fit_pf}
#| results: asis
#| echo: false

str_glue("#### Inserting the predictions
         
         Now we insert the model predictions into our blood data.")
```

```{r pf-update,echo=fit_pf, eval=fit_pf}
bidsdata <- inner_join(bidsdata, pf_data) %>% 
  mutate(preds = map(preds, ~mutate(.x, 
                             parentFraction = as.numeric(
                               ifelse(parentFraction > 1,
                                          yes = 1,
                                          no = parentFraction))))) %>% 
  mutate(blooddata = map2(blooddata, preds, 
                          ~bd_addfitted(.x, time = .y$time, 
                                        predicted = as.numeric(.y$parentFraction), 
                                        modeltype = "parentFraction"))) %>% 
  select(-pf, -preds)

if("pf_fit" %in% colnames(bidsdata)) {
  bidsdata <- select(bidsdata, -pf_fit)
}
```


```{r pf-config_cleanup, echo=FALSE}
# Cleaning up the config
if( !do_gam ) {
  config$Model$ParentFraction$gam_k <- NULL
}

if( !do_hgam ) {
  config$Model$ParentFraction$hgam_formula <- NULL
}

if( do_hgam ) {
  config$Model$ParentFraction$set_ppf0 <- NULL
}

if( config$Model$ParentFraction$starttime == 0 ) {
  config$Model$ParentFraction$starttime <- NULL
}

if( config$Model$ParentFraction$endtime == Inf ) {
  config$Model$ParentFraction$endtime <- NULL
}
```



### Blood-to-Plasma Ratio

The selected modelling approach for modelling the blood-to-plasma (BPR) ratio data is `r config$Model$BPR$Method`.

```{r bpr-setup}
#| echo: false

do_constant <- (config$Model$BPR$Method=="Fit Individually: Constant")
do_linear <-(config$Model$BPR$Method=="Fit Individually: Linear")
do_gam <-(config$Model$BPR$Method=="Fit Individually: GAM")
do_hgam <-(config$Model$BPR$Method=="Fit Hierarchically: HGAM")

fit_indiv <- str_detect(config$Model$BPR$Method, "Fit Individually")
fit_hier <- str_detect(config$Model$BPR$Method, "Fit Hierarchically")

fit_bpr <- config$Model$BPR$Method != "Interpolation"

use_fitted <- do_constant || do_hgam
use_fit <- do_linear || do_gam

parametric_bpr <- any(do_constant, do_linear)
# nonparam_bpr <- !parametric_bpr
```

```{r bpr-constant,echo=do_constant, eval=do_constant}
#| fig-height: 4
#| fig-width: 5

# Extract Data
bpr_data <- bidsdata %>%
  mutate(bpr = map(blooddata, ~bd_extract(.x, output="BPR"))) %>%
  mutate(bpr = map(bpr, ~.x %>%
           filter(time >= as.numeric(config$Model$BPR$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$BPR$endtime)*60))) %>%
  select(pet, bpr)

# Fit Model
bpr_data <- bpr_data %>%
  mutate(bpr_fit = map(bpr, ~lm(bpr ~ 1, data=.x)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(bpr_data$bpr, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=10)

bpr_data <- bpr_data %>%
  mutate(preds = map(bpr_fit, ~tibble(
    time = predtimes,
    bpr = as.numeric(coef(.x)[1]))))

bpr_data <- bpr_data %>%
  mutate(preds = map(bpr_fit, ~tibble(
    time = predtimes)),
         preds = map2(bpr_fit, preds, ~.y %>% 
                        mutate(bpr = predict(.x, newdata=.y))))

# Plot
pmap(list(bpr_data$bpr, bpr_data$preds, bpr_data$pet), plot_bpr_preds)
```

```{r bpr-linear,echo=do_linear, eval=do_linear}
#| fig-height: 4
#| fig-width: 5

# Extract Data
bpr_data <- bidsdata %>%
  mutate(bpr = map(blooddata, ~bd_extract(.x, output="BPR"))) %>%
  mutate(bpr = map(bpr, ~.x %>%
           filter(time >= as.numeric(config$Model$BPR$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$BPR$endtime)*60))) %>%
  select(pet, bpr)

# Fit Model
bpr_data <- bpr_data %>%
  mutate(bpr_fit = map(bpr, ~lm(bpr ~ time, data=.x)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(bpr_data$bpr, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

bpr_data <- bpr_data %>%
  mutate(preds = map(bpr_fit, ~tibble(
    time = predtimes)),
         preds = map2(bpr_fit, preds, ~.y %>% 
                        mutate(bpr = predict(.x, newdata=.y))))

# Plot
pmap(list(bpr_data$bpr, bpr_data$preds, bpr_data$pet), plot_bpr_preds)
```



```{r, eval=parametric_bpr}
#| results: asis
#| echo: false

str_glue("The fitted parameters are shown below.")
```

```{r bpr-parameters,echo=parametric_bpr, eval=parametric_bpr}
bpr_pars <- bpr_data %>% 
  mutate(bpr_pars = map(bpr_fit, ~as_tibble(as.list(coef(.x))))) %>% 
  select(pet, bpr_pars)

bpr_pars %>% 
  unnest() %>% 
  kable(digits=3)
```



```{r bpr-gam,echo=do_gam, eval=do_gam}
#| fig-height: 4
#| fig-width: 5

# Extract Data
bpr_data <- bidsdata %>%
  mutate(bpr = map(blooddata, ~bd_extract(.x, output="BPR"))) %>%
  mutate(bpr = map(bpr, ~.x %>%
           filter(time >= as.numeric(config$Model$BPR$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$BPR$endtime)*60))) %>%
  select(pet, bpr)

# Fit Model
bpr_data <- bpr_data %>%
  mutate(bpr_fit = map(bpr, ~gam(bpr ~ s(time, 
                                         k = as.numeric(config$Model$BPR$gam_k)), 
                                 data=.x, method = "REML",
                                 family=scat())))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(bpr_data$bpr, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

bpr_data <- bpr_data %>%
  mutate(preds = map2(bpr_fit, bpr,
                      ~gratia::fitted_values(.x, data=list(time=predtimes)))) %>% 
  mutate(preds = map(preds, ~rename(.x, bpr = .fitted)))



# Plot
pmap(list(bpr_data$bpr, bpr_data$preds, bpr_data$pet), plot_bpr_preds)
```

```{r bpr-hgam-fit,echo=do_hgam, eval=do_hgam}
#| fig-height: 4
#| fig-width: 8

# Extract Data
bpr_data <- bidsdata %>%
  mutate(bpr = map(blooddata, ~bd_extract(.x, output="BPR"))) %>%
  mutate(bpr = map(bpr, ~.x %>%
           filter(time >= as.numeric(config$Model$BPR$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$BPR$endtime)*60))) %>%
  select(pet, bpr)

bpr_data_long <- bpr_data %>% 
  inner_join(bidsdata_attributes) %>% 
  unnest(bpr) %>% 
  mutate(across(is.character, as.factor))

# Fit Model
hgam_formula <- as.formula(
  paste0(
    "bpr ~ ",
    config$Model$BPR$hgam_formula )
  )

bpr_hgam_fit = mgcv::gam(formula = hgam_formula, 
                         data=bpr_data_long, method = "REML",
                         family=scat())

# Diagnostics
k.check(bpr_hgam_fit)
appraise(bpr_hgam_fit)
draw(bpr_hgam_fit, scales = "fixed")
```

```{r bpr-hgam-plot,echo=do_hgam, eval=do_hgam}
#| fig-height: 4
#| fig-width: 5

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(bpr_data$bpr, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=1000)

hgam_preds <- tidyr::expand_grid(bidsdata_attributes,
                                 time = predtimes)

hgam_preds <- gratia::fitted_values(bpr_hgam_fit, data=hgam_preds) %>% 
  rename(bpr = .fitted) 

bpr_data <- inner_join(bpr_data,
                      hgam_preds %>% 
                      group_by(pet) %>% 
                      nest(preds = -pet))

# Plot
pmap(list(bpr_data$bpr, bpr_data$preds, bpr_data$pet), plot_bpr_preds)
```

```{r, eval=fit_bpr}
#| results: asis
#| echo: false

str_glue("#### Inserting the predictions
         
         Now we insert the model predictions into our blood data.")
```

```{r bpr-update-fitted,echo=use_fitted, eval=use_fitted}
bidsdata <- inner_join(bidsdata, bpr_data) %>% 
  mutate(blooddata = map2(blooddata, preds, 
                          ~bd_addfitted(.x, time = .y$time, 
                                        predicted = as.numeric(.y$bpr), 
                                        modeltype = "BPR"))) %>% 
  select(-bpr, -preds)

if("bpr_fit" %in% colnames(bidsdata)) {
  bidsdata <- select(bidsdata, -bpr_fit)
}
```

```{r bpr-update-fit,echo=use_fit, eval=use_fit}
bidsdata <- inner_join(bidsdata, bpr_data) %>% 
  mutate(blooddata = map2(blooddata, bpr_fit, 
                          ~bd_addfit(.x, fit = .y,
                                        modeltype = "BPR"))) %>% 
  select(-bpr, -preds)

if("bpr_fit" %in% colnames(bidsdata)) {
  bidsdata <- select(bidsdata, -bpr_fit)
}
```


```{r bpr-config_cleanup, echo=FALSE}
# Cleaning up the config
if( !do_gam ) {
  config$Model$BPR$gam_k <- NULL
}

if( !do_hgam ) {
  config$Model$BPR$hgam_formula <- NULL
}

if( config$Model$BPR$starttime == 0 ) {
  config$Model$BPR$starttime <- NULL
}

if( config$Model$BPR$endtime == Inf ) {
  config$Model$BPR$endtime <- NULL
}
```

### Arterial Input Function

The selected modelling approach for modelling the arterial input function (AIF) data is `r config$Model$AIF$Method`.

```{r aif-setup}
#| echo: false

do_triexp <-(config$Model$AIF$Method=="Fit Individually: Linear Rise, Triexponential Decay")
do_feng <-(config$Model$AIF$Method=="Fit Individually: Feng")
do_fengconv <-(config$Model$AIF$Method=="Fit Individually: FengConv")
do_splines <-(config$Model$AIF$Method=="Fit Individually: Splines")

aif_model_shortname <- case_when(
  do_triexp    ~ "triexp",
  do_feng      ~ "feng",
  do_fengconv  ~ "fengconv",
  TRUE         ~ "other"
)

fit_aif <- config$Model$AIF$Method != "Interpolation"

parametric_aif <- any(do_triexp, do_feng, do_fengconv)
nonparam_aif <- do_splines
```

```{r aif-triexp,echo=do_triexp, eval=do_triexp}
#| fig-height: 4
#| fig-width: 9

# Extract Data
aif_data <- bidsdata %>%
  mutate(aif = map(blooddata, ~bd_extract(.x, output="AIF"))) %>%
  mutate(aif = map(aif, ~.x %>%
           filter(time >= as.numeric(config$Model$AIF$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$AIF$endtime)*60))) %>%
  select(pet, aif)

# Fit Model
expdecay_props <- as.numeric(
  config$Model$AIF$expdecay_props)

expdecay_props <- ifelse( is.na(expdecay_props),
                          yes = c(1/60, 0.1),
                          no = expdecay_props)

aif_data <- aif_data %>%
  mutate(aif_fit = map(aif, ~blmod_exp(time = .x$time, activity = .x$aif,
                                       Method = .x$Method)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(aif_data$aif, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=6000)

aif_data <- aif_data %>%
  mutate(preds = map(aif_fit, ~tibble(
    time = predtimes) %>%
      mutate(aif = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(aif_data$aif, aif_data$preds, aif_data$pet), plot_aif_preds)

# Parameters
aif_data <- aif_data %>% 
  mutate(aif_pars = map(aif_fit, "par")) %>% 
  # Conversion
  mutate(aif_pars = map(aif_pars, ~.x %>% 
                mutate(A = A*1000,  # kBq to Bq
                       B = B*1000,
                       C = C*1000,
                       peakval = peakval*1000)))
```

```{r aif-feng,echo=do_feng, eval=do_feng}
#| fig-height: 4
#| fig-width: 9

# Extract Data
aif_data <- bidsdata %>%
  mutate(aif = map(blooddata, ~bd_extract(.x, output="AIF"))) %>%
  mutate(aif = map(aif, ~.x %>%
           filter(time >= as.numeric(config$Model$AIF$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$AIF$endtime)*60))) %>%
  select(pet, aif)

# Fit Model
expdecay_props <- as.numeric(
  config$Model$AIF$expdecay_props)

expdecay_props <- ifelse( is.na(expdecay_props),
                          yes = c(1/60, 0.1),
                          no = expdecay_props)

aif_data <- aif_data %>%
  mutate(aif_fit = map(aif, ~blmod_feng(time = .x$time, activity = .x$aif,
                                       Method = .x$Method)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(aif_data$aif, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=6000)

aif_data <- aif_data %>%
  mutate(preds = map(aif_fit, ~tibble(
    time = predtimes) %>%
      mutate(aif = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(aif_data$aif, aif_data$preds, aif_data$pet), plot_aif_preds)

# Parameters
aif_data <- aif_data %>% 
  mutate(aif_pars = map(aif_fit, "par")) %>% 
  # Conversion
  mutate(aif_pars = map(aif_pars, ~.x %>% 
                mutate(A = A*1000,  # kBq to Bq
                       B = B*1000,
                       C = C*1000)))
```

```{r aif-fengconv,echo=do_fengconv, eval=do_fengconv}
#| fig-height: 4
#| fig-width: 9

# Extract Data
aif_data <- bidsdata %>%
  mutate(aif = map(blooddata, ~bd_extract(.x, output="AIF"))) %>%
  mutate(aif = map(aif, ~.x %>%
           filter(time >= as.numeric(config$Model$AIF$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$AIF$endtime)*60))) %>%
  select(pet, aif)

# Fit Model
expdecay_props <- as.numeric(
  config$Model$AIF$expdecay_props)

expdecay_props <- ifelse( is.na(expdecay_props),
                          yes = c(1/60, 0.1),
                          no = expdecay_props)

inftime <- config$Model$AIF$inftime

if( is.na(inftime)[1] ) {  # Fit inftime completely
  aif_data <- aif_data %>%
  mutate(aif_fit = map(aif, ~blmod_fengconv(time = .x$time, activity = .x$aif,
                                       Method = .x$Method )))
} else {
  
  aif_data <- aif_data %>%
  mutate(aif_fit = map(aif, ~blmod_fengconv(time = .x$time, activity = .x$aif,
                                       Method = .x$Method, inftime = inftime
                                       )))
  
}


# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(aif_data$aif, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=6000)

aif_data <- aif_data %>%
  mutate(preds = map(aif_fit, ~tibble(
    time = predtimes) %>%
      mutate(aif = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(aif_data$aif, aif_data$preds, aif_data$pet), plot_aif_preds)

# Parameters
aif_data <- aif_data %>% 
  mutate(aif_pars = map(aif_fit, "par")) %>% 
  # Conversion
  mutate(aif_pars = map(aif_pars, ~.x %>% 
                mutate(A = A*1000,  # kBq to Bq
                       B = B*1000,
                       C = C*1000)))
```



```{r, eval=parametric_aif}
#| results: asis
#| echo: false

str_glue("The fitted parameters are shown below.")
```

```{r aif-parameters,echo=parametric_aif, eval=parametric_aif}
aif_pars <- aif_data %>% 
  mutate(aif_pars = map(aif_fit, "par")) %>% 
  select(pet, aif_pars)

aif_pars %>% 
  unnest(aif_pars) %>% 
  kable(digits=3)
```


```{r aif-splines,echo=do_splines, eval=do_splines}
#| fig-height: 4
#| fig-width: 9

# Extract Data
aif_data <- bidsdata %>%
  mutate(aif = map(blooddata, ~bd_extract(.x, output="AIF"))) %>%
  mutate(aif = map(aif, ~.x %>%
           filter(time >= as.numeric(config$Model$AIF$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$AIF$endtime)*60))) %>%
  select(pet, aif)

# Fit Model
kb <- ifelse(config$Model$AIF$spline_kb == "", yes = 10, 
             no = config$Model$AIF$spline_kb)
ka_m <- ifelse(config$Model$AIF$spline_ka_m == "", yes = 10, 
             no = config$Model$AIF$spline_ka_m)
ka_a <- ifelse(config$Model$AIF$spline_ka_a == "", yes = 10, 
             no = config$Model$AIF$spline_ka_a)

aif_data <- aif_data %>%
  mutate(aif_fit = map(aif, ~blmod_splines(time = .x$time, activity = .x$aif,
                                       Method = .x$Method, k_before = kb,
                                       k_after_d = ka_m, k_after_c = ka_a)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(aif_data$aif, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=6000)

aif_data <- aif_data %>%
  mutate(preds = map(aif_fit, ~tibble(
    time = predtimes) %>%
      mutate(aif = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(aif_data$aif, aif_data$preds, aif_data$pet), plot_aif_preds)
```

```{r, eval=fit_aif}
#| results: asis
#| echo: false

str_glue("#### Inserting the predictions
         
         Now we insert the model predictions into our blood data.")
```

```{r aif-update,echo=parametric_aif, eval=parametric_aif}
bidsdata <- inner_join(bidsdata, aif_data) %>% 
  mutate(blooddata = map2(blooddata, aif_fit, 
                          ~bd_addfit(.x, fit = .y,
                                        modeltype = "AIF"))) %>% 
  select(-aif, -preds)

if("aif_fit" %in% colnames(bidsdata)) {
  bidsdata <- select(bidsdata, -aif_fit)
}
```


```{r aif-update_nonpara,echo=nonparam_aif, eval=nonparam_aif}
bidsdata <- inner_join(bidsdata, aif_data) %>% 
  mutate(preds = map(preds, ~mutate(.x, 
                             aif = as.numeric(
                               ifelse(aif < 0,
                                          yes = 0,
                                          no = aif))))) %>% 
  mutate(blooddata = map2(blooddata, preds, 
                          ~bd_addfitted(.x, time = .y$time, 
                                        predicted = as.numeric(.y$aif), 
                                        modeltype = "AIF"))) %>% 
  select(-aif, -preds)

if("aif_fit" %in% colnames(bidsdata)) {
  bidsdata <- select(bidsdata, -aif_fit)
}
```


```{r aif-config_cleanup, echo=FALSE}
# Cleaning up the config
if( !do_splines ) {
  config$Model$AIF$spline_kb <- NULL
  config$Model$AIF$spline_ka_m <- NULL
  config$Model$AIF$spline_ka_a <- NULL
}

if( !do_fengconv ) {
  config$Model$AIF$inftime <- NULL
}

if( !(any(do_triexp, do_feng, do_fengconv)) ) {
  config$Model$AIF$expdecay_props <- NULL
}

if( config$Model$AIF$starttime == 0 ) {
  config$Model$AIF$starttime <- NULL
}

if( config$Model$AIF$endtime == Inf ) {
  config$Model$AIF$endtime <- NULL
}
```


### Whole Blood

The selected modelling approach for modelling the whole blood (WB) data is `r config$Model$WholeBlood$Method`.

```{r wb-setup}
#| echo: false

do_splines <-(config$Model$WholeBlood$Method=="Fit Individually: Splines")

fit_wb <- config$Model$WholeBlood$Method != "Interpolation"
```

```{r wb-splines,echo=do_splines, eval=do_splines}
#| fig-height: 4
#| fig-width: 9

# Extract Data
wb_data <- bidsdata %>%
  mutate(wb = map(blooddata, ~bd_extract(.x, output="Blood"))) %>%
  mutate(wb = map(wb, ~.x %>%
           filter(time >= as.numeric(config$Model$WholeBlood$starttime)*60) %>%
           filter(time <= as.numeric(config$Model$WholeBlood$endtime)*60))) %>%
  select(pet, wb)

# Fit Model
kb <- ifelse(config$Model$WholeBlood$spline_kb == "", yes = 10, 
             no = config$Model$WholeBlood$spline_kb)
ka_m <- ifelse(config$Model$WholeBlood$spline_ka_m == "", yes = 10, 
             no = config$Model$WholeBlood$spline_ka_m)
ka_a <- ifelse(config$Model$WholeBlood$spline_ka_a == "", yes = 10, 
             no = config$Model$WholeBlood$spline_ka_a)

wb_data <- wb_data %>%
  mutate(wb_fit = map(wb, ~blmod_splines(time = .x$time, activity = .x$activity,
                                       Method = .x$Method, k_before = kb,
                                       k_after_d = ka_m, k_after_c = ka_a)))

# Make Predictions
mintime <- 0
maxtime <- max(map_dbl(wb_data$wb, ~max(.x$time)))
predtimes <- seq(from=mintime, to=maxtime, length.out=6000)

wb_data <- wb_data %>%
  mutate(preds = map(wb_fit, ~tibble(
    time = predtimes) %>%
      mutate(activity = predict(.x, newdata=list(time=time)))))

# Plot
pmap(list(wb_data$wb, wb_data$preds, wb_data$pet), plot_wb_preds)
```

```{r, eval=fit_wb}
#| results: asis
#| echo: false

str_glue("#### Inserting the predictions
         
         Now we insert the model predictions into our blood data.")
```


<!-- ```{r wb-update,echo=fit_wb, eval=fit_wb} -->
<!-- bidsdata <- inner_join(bidsdata, wb_data) %>%  -->
<!--   mutate(blooddata = map2(blooddata, wb_fit,  -->
<!--                           ~bd_addfit(.x, fit = .y, -->
<!--                                         modeltype = "Blood"))) %>%  -->
<!--   select(-wb, -preds) -->

<!-- if("wb_fit" %in% colnames(bidsdata)) { -->
<!--   bidsdata <- select(bidsdata, -wb_fit) -->
<!-- } -->
<!-- ``` -->


```{r wb-update,echo=fit_wb, eval=fit_wb}
bidsdata <- inner_join(bidsdata, wb_data) %>% 
  mutate(preds = map(preds, ~mutate(.x, 
                             activity = as.numeric(
                               ifelse(activity < 0,
                                          yes = 0,
                                          no = activity))))) %>% 
  mutate(blooddata = map2(blooddata, preds, 
                          ~bd_addfitted(.x, time = .y$time, 
                                        predicted = as.numeric(.y$activity), 
                                        modeltype = "Blood"))) %>% 
  select(-wb, -preds)

if("wb_fit" %in% colnames(bidsdata)) {
  bidsdata <- select(bidsdata, -wb_fit)
}
```


```{r wb-config_cleanup, echo=FALSE}
# Cleaning up the config
if( !do_splines ) {
  config$Model$WholeBlood$spline_kb <- NULL
  config$Model$WholeBlood$spline_ka_m <- NULL
  config$Model$WholeBlood$spline_ka_a <- NULL
}

if( config$Model$WholeBlood$starttime == 0 ) {
  config$Model$WholeBlood$starttime <- NULL
}

if( config$Model$WholeBlood$endtime == Inf ) {
  config$Model$WholeBlood$endtime <- NULL
}
```

## Final Plotting

```{r}
#| echo: false

final_plotting <- any(
  fit_pf,
  fit_bpr,
  fit_aif,
  fit_wb
)

all_interp <- !final_plotting
```

```{r, eval=final_plotting}
#| results: asis
#| echo: false

str_glue("Below are shown the fits to all the blood data after modelling. Inspect these plots to make sure that everything seems fine.")
```

```{r final-plotting, fig.height=5, fig.width=11, eval=final_plotting, echo=final_plotting}
#| warning: false
#| message: false
#| fig-height: 5
#| fig-width: 11

map2(bidsdata$blooddata, bidsdata$pet,
     plot_blooddata_extra)
```

```{r, eval=all_interp, echo=FALSE}
#| results: asis

str_glue("Because no modelling was performed, the final plots are the same as the initial plots.")
```

## Output

First, we create the relevant filenames, and delete any files in the relevant folders.

```{r prep-output-filenames, results='hide'}
bidsdata <- bidsdata %>% 
  mutate(bloodfilename = map_chr(filedata, ~.x %>% 
                                  filter(measurement == "blood") %>% 
                                  filter(str_detect(path, "manual_blood.json")) %>% 
                                  slice(1) %>% 
                                  pull(path) )) %>%
  # Blood tsv file
  mutate(output_basename = basename(bloodfilename),
         output_basename = str_replace(output_basename,
                                       "_recording-manual_blood.json",
                                       "_inputfunction.tsv"),
         output_folder = dirname(bloodfilename),
         output_filename = paste0(params$studypath, "/derivatives/bloodstream", 
                                  config_suffix, "/",
                                  output_folder, "/", output_basename)) %>% 
  # Blood json file
  mutate(output_json_filename = str_replace(output_filename, "_inputfunction.tsv",
                                           "_inputfunction.json")) %>% 
  # Blood config file
  mutate(output_cfg_filename = str_replace(output_filename, "_inputfunction.tsv",
                                           "_config.json"))

file.remove(bidsdata$output_filename)
file.remove(bidsdata$output_json_filename)
file.remove(bidsdata$output_cfg_filename)
```


Now the final curves need to be interpolated...

```{r interpolating}
bidsdata <- bidsdata %>% 
  mutate(input = map(blooddata, bd_create_input)) %>% 
  mutate(input = map(input, ~rename(.x,
                          "time" = Time,
                          "whole_blood_radioactivity" = Blood,
                          "plasma_radioactivity" = Plasma,
                          "metabolite_parent_fraction" = ParentFraction,
                          AIF = AIF))) %>% 
  #unit_conversion
  mutate(input = map(input, ~mutate(.x,
         # min to sec                            
         time = time * 60,
         # kBq to Bq
         whole_blood_radioactivity = unit_convert(whole_blood_radioactivity, 
                                                  from_units = "kBq", 
                                                  to_units = "Bq"),
         plasma_radioactivity = unit_convert(plasma_radioactivity, "kBq", "Bq"),
         AIF = unit_convert(AIF, "kBq", "Bq"))))
```

... and save the tabular tsv files to the derivatives folder.

```{r save-tsvs, warning=FALSE}
walk( dirname(bidsdata$output_filename), 
      dir.create, recursive=T)

# Save interpolated tsv files
walk2(bidsdata$input,
     bidsdata$output_filename, ~write_delim(.x, file=.y, 
                                            delim = "\t"))
```


We also save json sidecars to accompany all the tabular data.

```{r save-json-sidecars}
output_description <- list(
  time = list(
      Description = "Interpolated time in relation to time zero defined in _pet.json",
      Units = "s"
    ),
    whole_blood_radioactivity = list(
      Description = "Estimated interpolated radioactivity in whole blood samples",
      Units = "Bq"
    ),
    plasma_radioactivity = list(
      Description = "Estimated interpolated radioactivity in whole plasma samples",
      Units = "Bq"
    ),
    AIF = list(
      Description = "Estimated interpolated radioactivity in metabolite-corrected arterial plasma samples",
      Units = "Bq"
    )
)

# Save interpolated json sidecars
walk(bidsdata$output_json_filename, ~write_json(output_description, path = .x,
                                                pretty=TRUE))
```



And finally, we include config files describing the models used for each step.

```{r, eval=parametric_aif, echo=parametric_aif}
#| results: asis
#| echo: false

str_glue("Because we used a parametric model for the AIF, we will first add the AIF parameters to the output. These parameters are refer to Bq/mL and seconds.")
```

```{r save_config_parametricaif, eval=parametric_aif, echo=parametric_aif}
aif_pars <- aif_data %>%
  select(pet, aif_parameters = aif_pars)

output_config <- config$Model


add_aifpars_to_config <- function(output_config, aif_parameters) {
  output_config$AIF$Fit$Parameters = aif_parameters
  output_config$AIF$Fit$Units$time = "s"
  output_config$AIF$Fit$Units$AIF = "Bq"
  output_config
}


bidsdata <- bidsdata %>%
  inner_join(aif_pars, by="pet") %>%
  mutate(output_configdata = map(aif_parameters,
                                 ~add_aifpars_to_config(output_config, .x)))


walk2(bidsdata$output_configdata, bidsdata$output_cfg_filename, 
     ~jsonlite::write_json(.x, path = .y, 
                           pretty=T))
```


```{r save_config_nonparametric, eval=nonparam_aif, echo=nonparam_aif}
output_config <- config$Model

walk(bidsdata$output_cfg_filename, 
     ~jsonlite::write_json(output_config, path = .x, pretty=T))
```


And finally, we save a dataset description file

```{r}
dataset_description <- list(
  Name = "bloodstream Outputs",
  BIDSVersion = "1.7.0",
  DatasetType = "derivative",
  GeneratedBy = list(
    Name = "bloodstream",
    Version = as.character(packageVersion("bloodstream")),
    Container = NULL
  )
)

jsonlite::write_json(dataset_description, 
                     path = paste0(params$studypath, 
                                   "/derivatives/bloodstream", config_suffix, 
                                   "/dataset_description.json"),
                     pretty = T)
```


# Session Info

```{r sessioninfo}
sessionInfo()
```

